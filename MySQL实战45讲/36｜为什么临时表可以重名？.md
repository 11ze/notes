---
title: 36｜为什么临时表可以重名？
tags:
  - MySQL
created: 2023-05-17T22:07:48+08:00
updated: 2024-05-13T23:00:00+08:00
---

- 本章的内存表都是用户手动创建的

## 临时表和内存表不同

- 内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。
- 临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。
- 临时表也可以使用 Memory 引擎。

## 临时表的特性

- 一个临时表只能被创建它的 session 访问，对其他线程不可见。
    - 在 session 结束的时候会自动删除临时表
    - 不同 session 的临时表可以重名
- 临时表可以与普通表同名。
    - session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。
- show tables 命令不显示临时表。

## 临时表的应用

- 经常用在复杂查询的优化过程中
- 典型：分库分表系统的跨库查询
    - 第一种思路：在 proxy 层的进程代码中实现排序
        - 开发工作量比较大
        - 对 proxy 端压力大：内存、CPU
    - 第二种思路：把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。
        - 在汇总库创建临时表
        - 然后分库拿到需要的数据，插入到临时表中

## 临时表可以重名

- `#sql{进程 id}_{线程 id}_ 序列号.frm` 文件保存表结构定义
  - 通过 select @@tmpdir 命令可以查看临时文件目录
- 5.6 以及之前的版本：`#sql{进程 id}_{线程 id}_ 序列号.ibd` 文件存放数据
- 5.7 开始：MySQL 引入一个临时文件表空间，专门用来存放临时文件的数据。不需要再创建 ibd 文件
- 内存里面
  - 每个表对应一个 table_def_key
    - 普通表：库名 + 表名
    - 临时表：库名 + 表名 + server_id + thread_id
  - 在实现上，每个线程都维护了自己的临时表链表
    - 每次 session 内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表
    - 在 session 结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE + 表名”操作
    - 建议用完手动删除

## 临时表和主备复制

- 只在 binlog_format=statment/mixed 的时候，binlog 中才会记录临时表的操作。
  - row 格式会记录操作的数据
    - 删除临时表的语句会被改写，因为备库找不到临时表会报错
    - 有 `/* generated by server */` 说明是被服务端改写过的语句
- MySQL 在记录 binlog 的时候，会把主库执行这个语句的线程 id 写到 binlog 中。这样，在备库的应用线程就能够知道执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key：

## 思考题

- 可以用 alter table 修改临时表的表名，不能使用 rename 语法的原因？
  - 在实现上，执行 rename table 语句的时候，要求按照“库名/表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的 frm 文件放在 tmpdir 目录，并且文件名的规则是 `#sql{进程 id}_{线程 id}_ 序列号.frm`，因此会报“找不到文件名”的错误。

## 评论区

- “临时表会自动回收”这个功能，主要用于“应用程序异常断开、MySQL异常重启”后，不需要主动去删除表。平时正常使用的时候，建议用完手动删除。
  - 如果 A 客户端在执行过程中创建了临时表，用完了连接就放回池子里面，没有做别的清理工作，然后新的客户端 B 复用这个连接，就可能会看到 A 的临时表。具体要看连接池怎么实现的。
- 一般一个事务创建临时表以后，读写分离就会默认接下来的请求都路由到主库
