---
title: 39｜自增主键为什么不是连续的？
tags:
  - MySQL
created: 2023-05-17T22:15:07+08:00
updated: 2024-05-13T23:00:00+08:00
---

## 自增值保存在哪儿？

- 表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。
- MyISAM 引擎的自增值保存在数据文件中。
- InnoDB
  - 在 MySQL 5.7 及之前的版本，自增值保存在内存里。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。
  - 在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。

## 自增值修改机制

1. 如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；
2. 如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。
    - 如果大于当前自增值，则会将插入的值的下一个大于的值作为自增值（基于步长）

## 自增锁的优化

- MySQL 5.0 版本，自增锁的范围是语句级别，等语句执行完才释放，影响并发度
- MySQL 5.1.22 引入一个新策略，新增参数 innodb_autoinc_lock_mode，默认值 1
    - 这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0 版本的策略
    - 这个参数的值被设置为 1 时：a. 普通 insert 语句，自增锁在申请之后就马上释放；b. 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；
        - 关于 b，如果像参数设置 2 一样，将会导致主备不一致（binlog_format=statement），因为事务的 binlog 是记录到一起的，在备库是连续，但在主库时却不一定是连续拿到自增值
        - 这里说的批量插入数据，包含的语句类型是 insert … select、replace … select 和 load data 语句。
        - b 的设定是因为“不知道要预先申请多少个 id”
    - 这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁。
    - 推荐 2 + binlog_format=row
- 在 8.0.3 版本后，innodb_autoinc_lock_mode 默认值是 2

## 对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略

1. 语句执行过程中，第一次申请自增 id，会分配 1 个；
2. 1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；
3. 依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。
    - 最后一次申请的如果没用完就浪费掉了
